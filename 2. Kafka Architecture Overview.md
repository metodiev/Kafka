##   Kafka Architecture Overview

### 1. High-Level Architecture
Kafka is built as a **distributed, fault-tolerant, high-throughput messaging and streaming platform**.  
Its architecture revolves around a **cluster of brokers** that store data in **topics** split into **partitions**, enabling parallelism and scalability.


### 2. Core Components

#### **Broker**
- A Kafka server that stores and serves data.
- Multiple brokers form a **Kafka cluster**.
- Each broker is identified by a unique ID.
- Stores **partitions** of topics and replicates them for fault tolerance.

#### **Topic**
- A **named logical channel** for messages.
- Producers write to topics; consumers read from them.
- Topics can be **partitioned** for parallel processing.

#### **Partition**
- A **unit of parallelism** within a topic.
- Each message in a partition has a unique **offset**.
- Partitions allow Kafka to scale horizontally.
- One broker is the **leader** for a partition; others are **followers** for replication.

#### **Producer**
- Application/service that **publishes messages** to a topic.
- Can specify the partition to write to (or let Kafka choose).
- Supports **acknowledgment modes** (acks=0, 1, all).

#### **Consumer**
- Application/service that **subscribes to topics** and processes messages.
- Organized into **consumer groups** for load balancing.
- Kafka tracks offsets for each consumer group.

#### **ZooKeeper / KRaft**
- ZooKeeper: Used in older versions for cluster coordination, metadata, and leader election.
- KRaft (Kafka Raft Metadata mode): Newer Kafka mode without ZooKeeper, using an internal Raft quorum for metadata management.


### 3. Message Flow
1. **Producer** sends a message to a **topic**.
2. Kafka assigns the message to a **partition** within the topic.
3. **Broker** stores the message and replicates it to follower brokers.
4. **Consumer** reads the message from the partition in order (by offset).


### 4. Key Design Choices
- **Partitioned log** storage for horizontal scaling.
- **Replication factor** for fault tolerance.
- **Retention policies** (time-based, size-based, or forever).
- **Pull-based consumption** â€“ consumers fetch messages at their own pace.


### 5. Benefits of This Architecture
- Scales to millions of messages per second.
- Highly available with replication.
- Parallel consumption via partitions.
- Decouples producers and consumers completely.



